
<script>
  if (window.location.href.indexOf('?page=DmZi_2024-04-13_浮点数') === -1) {
    window.location.href = '/index.html?page=./blog/DmZi_2024-04-13_浮点数.html';
  }
</script>
<h1 id="浮点数">浮点数</h1>
<h2 id="浮点数和定点数">浮点数和定点数</h2>
<p>在计算机系统中，小数可以通过浮点数和定点数两种格式存储，这两种格式在存储机制、精度和应用场景等方面各有特点。</p>
<ol type="1">
<li><strong>浮点数</strong>：
<ul>
<li><strong>存储方式</strong>：浮点数在计算机中的存储是基于科学记数法的，即数值被表示为
$ a ^b $ 的形式，其中 $ a $ 是尾数（mantissa）或有效数字，而 $ b $
表示指数（exponent）。在IEEE标准中，浮点数常见的格式如单精度（32位）和双精度（64位）。</li>
<li><strong>优点</strong>：浮点数的优势在于它的动态范围很大，可以表示非常大或非常小的数值，非常适合需要处理极端数据或变化范围很大的科学计算。</li>
<li><strong>缺点</strong>：浮点运算的缺点是其精度有限且运算速度相对较慢。由于存储方式的复杂性，它在进行运算时可能会引入舍入误差。</li>
</ul></li>
<li><strong>定点数</strong>：
<ul>
<li><strong>存储方式</strong>：定点数的存储则比较直接，将数值分为整数部分和小数部分，这两部分在内存中占据固定的位数。例如，在一个16位的定点数格式中，可能有8位用于整数部分，另外8位用于小数部分。</li>
<li><strong>优点</strong>：定点数的优点在于运算速度快，适合实时系统和硬件受限的系统，如嵌入式系统。定点运算通常比浮点运算更简单，消耗资源更少。</li>
<li><strong>缺点</strong>：其缺点是表达的数值范围和精度较低，不适合需要处理大范围或高精度计算的应用。</li>
</ul></li>
</ol>
<p>在选择使用浮点数还是定点数时，需要根据应用的具体需求来决定。例如，如果应用需要处理高精度的科学计算，通常选择浮点数；而如果应用在硬件资源受限且对计算速度有高要求的环境中，例如嵌入式设备或实时系统，则可能更倾向于使用定点数。</p>
<h2 id="浮点数存储细节">浮点数存储细节</h2>
<p>在浮点数的存储格式中，小数部分（也称为尾数或有效数字）确实是以类似于
0.xxxxx
的形式存储的，这部分通常被称为“规格化的尾数”。在IEEE标准的浮点数表示中，这种方式确保了数据的精度和效率。</p>
<p>具体来说，对于IEEE 754标准中的单精度和双精度浮点数：</p>
<ol type="1">
<li><strong>单精度（32位浮点数）</strong>：
<ul>
<li>其中1位用于符号位（表示正负）。</li>
<li>8位用于指数（exponent），用于表示数据的范围或者大小。</li>
<li>剩余的23位用于尾数（mantissa），存储小数部分。</li>
</ul></li>
<li><strong>双精度（64位浮点数）</strong>：
<ul>
<li>其中1位用于符号位。</li>
<li>11位用于指数。</li>
<li>剩余的52位用于尾数。</li>
</ul></li>
</ol>
<p>在规格化的尾数表示中，数值总是被表示为 <span
class="math inline">1.xxxxx \times 2^y</span>
的形式（注意这里是以2为基数的，因为使用的是二进制系统）。实际上，存储时通常会省略最前面的1（因为它是隐含的），只存储后面的
xxxxx
部分，这种方式称为隐含的最高位或隐含的1技术。这样做可以有效地增加一个额外的位数的精度，因为每个规格化的数的最高位都是1，所以没有必要显式地存储它。</p>
<p>因此，尽管小数部分实际存储的是类似于 xxxxx
的形式，但从逻辑上来说，它代表的是
0.xxxxx，这样可以更好地利用存储空间，同时也保证了浮点数的精度。</p>
<h2 id="存储负指数">存储负指数</h2>
<p>单精度浮点数遵循IEEE
754标准，这种格式使用32位二进制数来表示一个浮点数，分为三个部分：一个符号位、八位指数（exponent），和二十三位尾数（mantissa或fraction）。</p>
<p>为了存储一个如 <span class="math inline">2^{-10}</span>
这样的指数，IEEE
754标准使用了“偏移量”（或称为“偏置”）的概念。对于单精度浮点数，偏移量是127。这意味着指数部分是无符号数，而指数值的实际范围是通过从指数部分的值中减去127（偏移量）来得到的。</p>
<p>所以，如果我们要存储 <span class="math inline">2^{-10}</span>：</p>
<ul>
<li>指数部分（exponent）应该表示的实际值是 $ -10 $。</li>
<li>为了使用偏移表示法，我们将127加到实际指数值上，得到 $ -10 + 127 =
117 $。</li>
<li>然后将117转换为二进制形式，这将是指数部分的值。</li>
</ul>
<p>这里需要注意的一点是，实际的指数值范围并不包括全0和全1的情况：</p>
<ul>
<li>当指数部分为全0时，它表示一个非常特殊的数值，如规格化的最小值或者0。</li>
<li>当指数部分为全1时，它用于表示无穷大（Inf）或者NaN（不是一个数字）。</li>
</ul>
<p>因此，可用的实际指数值范围是从 <span class="math inline">1</span> 到
<span class="math inline">254</span>，这在偏移量的应用下转换为 $ -126 $
到 $ +127 $。即：</p>
<ul>
<li>指数部分二进制为 <span class="math inline">00000001</span> （十进制
<span class="math inline">1</span>）时，实际的指数值为 <span
class="math inline">1 - 127 = -126</span>。</li>
<li>指数部分二进制为 <span class="math inline">11111110</span> （十进制
<span class="math inline">254</span>）时，实际的指数值为 <span
class="math inline">254 - 127 = 127</span>。</li>
</ul>
<p>因此，当我们要存储 <span class="math inline">2^{-10}</span>
时，我们需要将实际指数 $ -10 $ 转换为存储指数，即 $ -10 + 127 = 117
$，然后将117表示为8位二进制数，这就是指数部分的存储形式。</p>
