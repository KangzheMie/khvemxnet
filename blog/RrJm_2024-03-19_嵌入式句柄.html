
<script>
    window.location.href = '/index.html?page=./blog/RrJm_2024-03-19_嵌入式句柄.html';
</script>
<h1 id="嵌入式句柄">嵌入式句柄</h1>
<h2 id="抽象的数据结构">抽象的数据结构</h2>
<p>句柄是一个抽象的数据结构，用于代表和管理对一个资源或对象的访问。在嵌入式系统中，这个概念经常用于表示和控制外设。</p>
<p>句柄本身作为软件层面的抽象，<strong>不直接对应硬件层面的实际物理地址</strong>。它通过软件框架内部的逻辑与外设的寄存器地址进行映射。这样，开发者通过操作句柄，间接地控制硬件，无需关心硬件的物理细节。</p>
<p>通过配置句柄并使用对应的库函数，开发者可以简化外设的控制和管理过程。<strong>库函数内部负责将句柄中的配置信息转换为对实际硬件寄存器的操作</strong>。这不仅提高了代码的可读性和可维护性，也增强了代码的可移植性。</p>
<p>库函数根据句柄中的信息，执行相应的寄存器读写操作，以实现对外设的初始化、配置以及控制等操作。这个过程对于开发者是透明的，开发者只需要关注句柄的配置，而不必深入到寄存器操作层面。</p>
<h2 id="使用库函数和句柄配置外设">使用库函数和句柄配置外设</h2>
<p>在嵌入式开发中，特别是使用STM32微控制器时，通过硬件抽象层（HAL,
Hardware Abstraction
Layer）进行外设配置的过程。HAL层的目的是简化硬件的直接操作，提供一套统一的API来管理不同的硬件资源，如GPIO、UART、SPI等。这种方式增强了代码的可移植性和可读性。</p>
<h3 id="配置句柄过程分析">配置句柄过程分析</h3>
<p>以STM32为例，每个外设（如UART）都有一个对应的句柄结构体（例如<code>UART_HandleTypeDef</code>），该结构体中包含了外设的配置信息以及外设的当前状态。用户通过配置这个句柄，HAL库能够根据句柄中的配置信息来初始化外设。</p>
<h4 id="步骤1声明外设句柄">步骤1：声明外设句柄</h4>
<p>首先，用户需要声明一个对应外设的句柄变量。例如，对于一个UART外设，用户可能会这样声明：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>UART_HandleTypeDef huart1<span class="op">;</span></span></code></pre></div>
<h4 id="步骤2填充句柄配置">步骤2：填充句柄配置</h4>
<p>然后，用户需要填充这个句柄结构体的字段，这些字段包括了外设的工作模式、速率、数据位数、停止位、奇偶校验等配置信息。例如，对于UART外设，配置过程可能如下：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>huart1<span class="op">.</span>Instance <span class="op">=</span> USART1<span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>huart1<span class="op">.</span>Init<span class="op">.</span>BaudRate <span class="op">=</span> <span class="dv">9600</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>huart1<span class="op">.</span>Init<span class="op">.</span>WordLength <span class="op">=</span> UART_WORDLENGTH_8B<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>huart1<span class="op">.</span>Init<span class="op">.</span>StopBits <span class="op">=</span> UART_STOPBITS_1<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>huart1<span class="op">.</span>Init<span class="op">.</span>Parity <span class="op">=</span> UART_PARITY_NONE<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>huart1<span class="op">.</span>Init<span class="op">.</span>Mode <span class="op">=</span> UART_MODE_TX_RX<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>huart1<span class="op">.</span>Init<span class="op">.</span>HwFlowCtl <span class="op">=</span> UART_HWCONTROL_NONE<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>huart1<span class="op">.</span>Init<span class="op">.</span>OverSampling <span class="op">=</span> UART_OVERSAMPLING_16<span class="op">;</span></span></code></pre></div>
<h4 id="步骤3调用初始化函数">步骤3：调用初始化函数</h4>
<p>配置完句柄后，用户需要调用相应的初始化函数（例如<code>HAL_UART_Init(&amp;huart1);</code>），这个函数会使用句柄中的配置信息来实际配置硬件寄存器，完成外设的初始化过程。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>HAL_UART_Init<span class="op">(&amp;</span>huart1<span class="op">);</span></span></code></pre></div>
<p>这个函数内部主要执行以下操作：</p>
<ol type="1">
<li><strong>参数校验</strong>：检查传入的句柄是否有效。</li>
<li><strong>外设时钟使能</strong>：为外设开启时钟，确保其能够正常工作。</li>
<li><strong>配置外设寄存器</strong>：根据句柄中的配置信息，设置外设的各项参数。</li>
<li><strong>状态更新</strong>：初始化完成后，更新句柄的状态，表示外设已经准备好。</li>
</ol>
<h3 id="结论">结论</h3>
<p>通过这种方式，HAL库抽象了底层硬件的复杂性，使得开发者可以通过配置和操作句柄的方式来控制硬件外设，无需深入了解外设的硬件细节。这大大提高了开发效率，也使得代码更加简洁和可维护。</p>
<h2 id="外设和寄存器的关系">外设和寄存器的关系</h2>
<p>在STM32微控制器，以及大多数嵌入式系统的硬件设计中，外设确实是被视作一段寄存器空间。每个外设，如通用输入输出（GPIO）、通用异步收发传输器（UART）、定时器等，都映射到了微控制器内存空间的特定区域。这些特定区域的地址包含了一系列的寄存器，通过这些寄存器可以配置和控制外设的行为。</p>
<p>寄存器是微控制器中用于存储设置或状态的小型存储设备，它们直接影响或反映了外设的行为。例如，一个UART外设将有寄存器来设置其波特率、数据格式、发送或接收使能等。</p>
<h3 id="初始化过程">初始化过程</h3>
<p>在初始化外设的过程中，确实是通过调用配置寄存器的函数来实现的。这个过程大致如下：</p>
<ol type="1">
<li><p><strong>使能时钟</strong>：首先，需要通过更改RCC（复位和时钟控制）模块的寄存器来为外设提供时钟信号。每个外设都连接到微控制器的时钟树上，而没有时钟信号，外设是无法工作的。</p></li>
<li><p><strong>配置寄存器</strong>：使用句柄中的参数，设置外设的配置寄存器。这包括设置工作模式、速率、数据位、奇偶校验等。这些参数直接写入到外设的寄存器中。</p></li>
<li><p><strong>使能外设</strong>：通过设置控制寄存器中的特定位，使外设开始工作。例如，对于UART，可能需要设置其控制寄存器中的“使能”位，以启动串行传输。</p></li>
</ol>
<h3 id="代码示例">代码示例</h3>
<p>以下是一个简化的例子，展示了如何通过直接操作寄存器来配置STM32的GPIO：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 使能GPIOA的时钟</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>RCC<span class="op">-&gt;</span>AHB1ENR <span class="op">|=</span> RCC_AHB1ENR_GPIOAEN<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 将PA5配置为输出模式</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>GPIOA<span class="op">-&gt;</span>MODER <span class="op">|=</span> GPIO_MODER_MODE5_0<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>GPIOA<span class="op">-&gt;</span>MODER <span class="op">&amp;=</span> <span class="op">~</span>GPIO_MODER_MODE5_1<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">// 设置PA5输出高电平</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>GPIOA<span class="op">-&gt;</span>BSRR <span class="op">=</span> GPIO_BSRR_BS5<span class="op">;</span></span></code></pre></div>
<p>在这个例子中，我们直接修改了RCC的AHB1ENR寄存器来使能GPIOA的时钟，然后通过修改GPIOA的MODER寄存器来设置其某个引脚的模式，最后通过BSRR寄存器来控制引脚的电平。</p>
