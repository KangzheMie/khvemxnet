
<script>
    window.location.href = '/index.html?page=./blog/RrJm_2024-03-19_异步操作与回调函数.html';
</script>
<h1 id="异步操作与回调函数">异步操作与回调函数</h1>
<h2 id="异步操作和事件驱动">异步操作和事件驱动</h2>
<p>异步操作是区别与正常程序运行的一种设计。在正常的程序中，命令线性的逐条运行。而在更多的应用中，程序需要等待一些「事件」的发生。当事件发生时，我们希望程序可以暂时离开原有的程序流，而运行用户指定的「回调函数」。</p>
<p><strong>定义和目的</strong>：异步操作允许程序在等待一个操作完成的同时，继续执行其他代码。这种设计主要用于处理那些可能会阻塞主线程或耗时较长的操作，比如文件读写、网络请求等。异步操作的目的是提高程序的效率和响应能力，避免因等待操作完成而造成的程序冻结。</p>
<p><strong>事件驱动</strong>：异步操作通常是事件驱动的。这意味着程序的执行不再是简单的顺序执行，而是由外部事件的发生来触发特定的操作。这些外部事件可以包括用户输入、文件I/O完成通知、网络数据到达等。</p>
<h2 id="回调函数和注册">回调函数和注册</h2>
<p>回调函数是一种在特定事件发生时被调用的函数。它是异步操作完成后处理结果的主要方式。通过回调函数，程序可以在适当的时候“回过头来”执行一些任务，比如处理异步操作的数据或更新用户界面。</p>
<p><strong>注册机制</strong>：将一个函数指定为某个事件的回调，本质上是一种注册机制。这个注册过程告诉程序或库，在特定事件发生时应该执行哪些代码。这种机制使得程序能够灵活地响应不同的事件。</p>
<p><strong>执行流程管理</strong>：“当系统发现了被注册的事件发生时，就会调用回调函数”，这个过程背后通常涉及到复杂的执行流程管理。在高级语言中，这可能涉及到事件循环和消息队列；在嵌入式系统中，可能涉及到中断服务例程和任务调度。</p>
<p>无论是在JavaScript的环境下，还是在嵌入式C编程中，回调机制的背后都存在着一套用于管理程序执行流程的机制，尽管这些机制在不同的环境中实现的方式各有差异。</p>
<h3 id="javascript中的事件循环和回调">JavaScript中的事件循环和回调</h3>
<p>让我们通过一个在Web开发中常见的异步操作示例——发起网络请求（例如，从服务器获取数据）来解释这个概念。这个例子将使用JavaScript，因为它广泛应用于处理异步操作。</p>
<p>假设我们需要从一个API获取用户信息，并在获取到信息后显示到网页上。这个过程涉及到一个网络请求，网络请求本身是一个典型的异步操作，因为我们不知道请求需要多久才能完成。</p>
<p>在JavaScript中，这种操作可以通过<code>fetch</code>函数实现，<code>fetch</code>函数用于发起网络请求并返回一个<code>Promise</code>对象，表示一个最终可能会完成（并产生一个值）或失败（并产生一个错误）的操作。</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 使用fetch函数发起异步网络请求</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fetch</span>(<span class="st">&#39;https://api.example.com/user&#39;</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(response <span class="kw">=&gt;</span> response<span class="op">.</span><span class="fu">json</span>()) <span class="co">// 当请求成功完成时，将响应转换为JSON</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">then</span>(data <span class="kw">=&gt;</span> {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(data)<span class="op">;</span> <span class="co">// 使用获取到的数据</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 例如，更新网页上的用户信息</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">document</span><span class="op">.</span><span class="fu">getElementById</span>(<span class="st">&#39;user-info&#39;</span>)<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> data<span class="op">.</span><span class="at">name</span><span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="fu">catch</span>(error <span class="kw">=&gt;</span> {</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">&#39;Error fetching user information:&#39;</span><span class="op">,</span> error)<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span></code></pre></div>
<ol type="1">
<li><p><strong>发起异步操作</strong>：调用<code>fetch</code>发起一个网络请求。这个操作是异步的，<code>fetch</code>函数立即返回一个<code>Promise</code>对象，而不是等待请求完成。</p></li>
<li><p><strong>继续执行后续代码</strong>：请求发出后，代码继续执行。在这个时候，你可以执行其他操作，比如显示一个加载动画，而不必等待网络请求完成。</p></li>
<li><p><strong>处理结果</strong>：当网络请求最终完成时，如果请求成功，<code>then</code>中的回调函数被调用，我们可以在这里处理请求的结果，比如将获取到的用户信息显示在网页上。如果请求失败，<code>catch</code>中的回调函数被调用，我们可以在这里处理错误。</p></li>
</ol>
<p>在JavaScript这样的高级语言中，特别是在浏览器环境下，“背后的管理机制”通常被称为<strong>事件循环</strong>（Event
Loop）。事件循环是JavaScript运行时环境的一部分，它负责监听事件并处理消息队列中的事件。当你使用<code>fetch</code>函数发起一个异步请求时：</p>
<ul>
<li><strong>异步操作注册</strong>：<code>fetch</code>操作被注册到浏览器提供的Web
API中，此操作完成后（无论成功还是失败），相应的结果会被放入事件队列。</li>
<li><strong>事件循环处理</strong>：事件循环持续监视事件队列，当事件队列中存在待处理的事件时，事件循环将逐一取出并执行对应的回调函数。</li>
</ul>
<p>这种机制允许JavaScript代码在不阻塞主线程的情况下执行异步操作，从而保证了用户界面的响应性和应用程序的性能。</p>
<h3 id="嵌入式c中的中断和回调">嵌入式C中的中断和回调</h3>
<p>在嵌入式C编程中，回调机制通常与<strong>中断系统</strong>紧密相关。中断系统是嵌入式设备硬件和操作系统（如果使用了操作系统）的一部分，用于响应外部或内部事件（如定时器溢出、外设事件等）：</p>
<ul>
<li><strong>中断注册</strong>：在初始化设备或应用程序时，通过设置特定的寄存器或使用特定的API来“注册”中断服务例程（ISR）。在某些情况下，这包括设置指向用户定义回调函数的函数指针。</li>
<li><strong>硬件中断处理</strong>：当相应的事件发生时（例如，数据接收完成），硬件中断触发，暂停当前执行流程，跳转到对应的ISR执行。ISR中可以进一步调用预先定义的回调函数来处理事件。</li>
</ul>
<p>在这个过程中，中断控制器（硬件的一部分）和（如果有的话）操作系统的调度器共同协作，管理着整个中断和回调的流程。</p>
<h3 id="补充">补充</h3>
<ul>
<li><p><strong>非阻塞特性</strong>：异步操作的非阻塞特性是其最重要的优点之一。这使得程序在等待异步操作完成的同时，仍能继续执行其他任务，从而提高整体的性能和用户体验。</p></li>
<li><p><strong>错误处理</strong>：在实现异步操作和回调函数时，合理的错误处理机制也非常重要。这确保了程序能够优雅地处理异步操作中可能发生的错误或异常情况。</p></li>
</ul>
<h2 id="阻塞与非阻塞的区别">阻塞与非阻塞的区别</h2>
<p>在讨论回调函数和异步操作时，“阻塞”和“非阻塞”是两个非常重要的概念，它们描述了程序在等待某个操作完成时的行为模式。</p>
<h3 id="阻塞操作">阻塞操作</h3>
<p>阻塞操作是<strong>指在等待某个操作</strong>（如I/O操作，比如从硬盘读取文件或从网络获取数据）完成时，当前线程暂停执行其他代码，直到该操作完成。在这种模式下，程序的执行流被阻塞，无法继续前进直到阻塞的操作完成。这在多线程环境中尤其问题，因为它可能导致资源浪费和性能下降，尤其是当阻塞操作涉及到等待外部资源时，如等待网络响应或磁盘I/O。</p>
<h3 id="非阻塞操作">非阻塞操作</h3>
<p>非阻塞操作允许程序在等待操作完成的同时继续执行其他任务。这是通过将操作委托给系统或库来实现的，操作完成后，通过某种形式的回调机制（如回调函数）通知程序。这种方式对于提高应用程序的响应性和效率非常重要，特别是在单线程环境中，如JavaScript运行在浏览器中。</p>
<h3 id="异步操作和回调函数">异步操作和回调函数</h3>
<p>异步操作通常意味着非阻塞，它允许程序发起一个操作后立即继续执行后续代码，不需要等待操作完成。当操作最终完成时（可能是在未来的某个时间点），通过预先定义的回调函数来处理结果。这种模式非常适合处理那些耗时的I/O操作，因为它避免了在等待操作完成时浪费宝贵的处理器资源。</p>
<h3
id="在嵌入式系统中的回调函数是否阻塞">在嵌入式系统中的回调函数是否阻塞</h3>
<p>在嵌入式系统中，回调函数本身通常是非阻塞的，尤其是在中断服务例程（ISR）中使用回调函数时。当事件发生（如定时器溢出、外设事件等）并触发中断时，中断服务例程会被调用，如果ISR中调用了用户定义的回调函数，<strong>这个函数通常需要快速执行并返回，以避免阻塞系统的其他部分</strong>。在这种情况下，回调函数应该执行尽可能少的工作，避免进行长时间的操作或等待，以免影响系统的实时响应性。</p>
<p>然而，是否阻塞也取决于回调函数的具体实现和它被调用的上下文。<strong>如果回调函数中包含了长时间的循环、延时等待或执行阻塞I/O操作，那么它仍然可以导致阻塞。</strong>因此，设计回调函数时，应该考虑到它们的执行环境和对系统性能的影响。</p>
<p>总的来说，无论是在嵌入式系统还是在其他编程环境中，使用回调函数进行异步编程都是一种有效的方法，可以提高程序的性能和响应性。然而，需要谨慎设计回调函数的逻辑，以避免不必要的阻塞和资源浪费。</p>
