
<script>
  if (window.location.href.indexOf('?page=RrJm_2024-03-24_使用Python批量重命名文件') === -1) {
    window.location.href = '/index.html?page=./blog/RrJm_2024-03-24_使用Python批量重命名文件.html';
  }
</script>
<h1 id="使用python批量重命名文件">使用Python批量重命名文件</h1>
<h2 id="切换目录-获取脚本路径path目录dir">切换目录 ——
获取脚本路径path目录dir</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 获取当前脚本文件的完整路径</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>work_path <span class="op">=</span> <span class="va">__file__</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 获取脚本文件所在的目录</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>work_dir <span class="op">=</span> os.path.dirname(work_path)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 改变当前工作目录到脚本文件所在目录</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>os.chdir(work_dir)</span></code></pre></div>
<h2 id="筛选文件-字符的匹配">筛选文件 —— 字符的匹配</h2>
<p>这里以一些.csv表格为例。</p>
<p>在某次实验中，收集到了如下的表格aCHbbbMcccMV.csv。其中abc是一些数字。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 遍历工作目录中的所有文件</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> filename <span class="kw">in</span> os.listdir(work_dir):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 检查文件名是否符合给定模式</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> filename.endswith(<span class="st">&#39;MV.csv&#39;</span>) <span class="kw">and</span> <span class="st">&#39;CH&#39;</span> <span class="kw">in</span> filename <span class="kw">and</span> <span class="st">&#39;M&#39;</span> <span class="kw">in</span> filename:</span></code></pre></div>
<p>其中<code>.endswith()</code>和<code>.startswith()</code>是两个判断字符串首尾的方法。</p>
<p><code>in</code>寻找字符串是否包含指定内容的方法。</p>
<p>这样我们就可以得到以<code>'MV.csv'</code>开头，名字中间包含<code>'CH'</code>和<code>'M'</code>的所有文件名了。</p>
<h2 id="解析文件-正则表达式">解析文件 —— 正则表达式</h2>
<p>如果想要把文件名解析得到各个组件，需要用到字符串的检测和匹配。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 正则表达式中包含三个捕获组</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>pattern <span class="op">=</span> <span class="vs">r&#39;(\d+)([A-Za-z]+)(\d+)&#39;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 待匹配的字符串</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>text <span class="op">=</span> <span class="st">&quot;123ABC456&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 进行匹配</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>match <span class="op">=</span> re.match(pattern, text)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> match:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 使用.groups()获取所有捕获组的内容</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    groups <span class="op">=</span> match.groups() <span class="co"># .groups()方法返回一个元组</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(groups)  <span class="co"># 输出: (&#39;123&#39;, &#39;ABC&#39;, &#39;456&#39;)</span></span></code></pre></div>
<p>正则表达式r’()([A-Za-z]+)()’中，括号<code>()</code>定义了三个捕获组，这些捕获组指定了正则表达式匹配时需要“记住”或捕获的部分。正则表达式引擎会按照这些捕获组在表达式中出现的顺序来进行匹配，并且每个捕获组会匹配到的字符串片段。</p>
<ol type="1">
<li><p><strong>第一个捕获组</strong>
<code>(\d+)</code>：匹配一个或多个数字。<code>\d</code>代表数字字符，<code>+</code>代表一个或多个前面的元素。因此，这个组会匹配连续的数字序列，直到遇到非数字字符。</p></li>
<li><p><strong>第二个捕获组</strong>
<code>([A-Za-z]+)</code>：匹配一个或多个英文字母（不区分大小写）。<code>[A-Za-z]</code>定义了一个字符集，包括所有大写和小写字母，<code>+</code>同样表示匹配一个或多个前面的元素。这个组会从第一个组匹配结束的地方开始，继续匹配直到遇到非字母字符。</p></li>
<li><p><strong>第三个捕获组</strong>
<code>(\d+)</code>：这个组的匹配逻辑与第一个组相同，也是匹配一系列的数字，但它会从第二个组匹配结束的位置开始匹配。</p></li>
</ol>
<p>正则表达式的匹配是按顺序进行的，从左到右。在匹配过程中，引擎会尝试按照表达式定义的模式依次匹配字符串。这意味着：</p>
<ul>
<li><strong>第一个捕获组</strong>会首先尝试匹配字符串开始的部分，找到一系列的数字。</li>
<li>接着，<strong>第二个捕获组</strong>从第一个组匹配结束的地方开始，尝试匹配一系列的字母。</li>
<li>最后，<strong>第三个捕获组</strong>接着上一个组的匹配结束位置，匹配后续的数字。</li>
</ul>
<p>只有当整个表达式成功匹配字符串时，<code>.match()</code>方法才会返回一个<code>match</code>对象，通过该对象的<code>.groups()</code>方法可以得到一个包含所有捕获组匹配结果的元组。<strong>如果在任何点上匹配失败，<code>.match()</code>会立即返回<code>None</code>，表示没有找到匹配。</strong></p>
<p>这个过程不仅是逐步的，还遵循贪婪匹配原则，意味着每个捕获组会尽可能多地匹配字符，直到满足下一个模式的需要或整个模式匹配完成。</p>
<p>所以对于实验数据aCHbbbMcccMV.csv，可以实验如下的脚本得到各个部分的数据。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 示例字符串</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>filename <span class="op">=</span> <span class="st">&quot;7HC123M456MV.csv&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 定义正则表达式</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 这个表达式假设“x”为数字，并且每部分至少有一个数字</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>pattern <span class="op">=</span> <span class="vs">r&#39;(\d+HC)(\d+M)(\d+MV)\.csv&#39;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 使用正则表达式搜索</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>match <span class="op">=</span> re.match(pattern, filename)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> match:</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 如果匹配成功，提取各个组</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    part1, part2, part3 <span class="op">=</span> match.groups()</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Matched parts:&quot;</span>, part1, part2, part3)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;No match found.&quot;</span>)</span></code></pre></div>
<h2 id="重命名文件">重命名文件</h2>
<p>假设已经根据解析文件名和各种手段完成了构建新的文件名。例如</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 构建新的文件名</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>new_filename <span class="op">=</span> <span class="st">&#39;A&#39;</span> <span class="op">+</span> filename</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 构建完整的旧文件路径和新文件路径</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>old_file <span class="op">=</span> os.path.join(work_dir, filename)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>new_file <span class="op">=</span> os.path.join(work_dir, new_filename)</span></code></pre></div>
<p>然后可以直接使用重命名的方法了</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 重命名文件</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>os.rename(old_file, new_file)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&#39;Renamed &quot;</span><span class="sc">{</span>filename<span class="sc">}</span><span class="ss">&quot; to &quot;</span><span class="sc">{</span>new_filename<span class="sc">}</span><span class="ss">&quot;&#39;</span>)</span></code></pre></div>
